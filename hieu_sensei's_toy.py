# -*- coding: utf-8 -*-
"""Hieu Sensei's Toy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cQwfw8Rv3zx68QIycKJCkkPtr2T6WwQM
"""

import numpy as np
import networkx as nx
from typing import Dict


def generate_planar_traffic_data(
    n_nodes: int = 100,
    n_vehicles: int = 30,
    n_communities: int = 4,
    p_in: float = 0.9,     # xác suất giữ cạnh trong cùng cộng đồng
    p_out: float = 0.7,    # xác suất giữ cạnh khác cộng đồng
    bandwidth_low: int = 5,
    bandwidth_high: int = 20,
    time_factor_low: float = 30.0,   # hệ số thời gian thấp (giây / đơn vị khoảng cách)
    time_factor_high: float = 90.0,  # hệ số thời gian cao
    seed: int = 42,
    time_window_seconds: float = 300.0,  # cửa sổ thời gian 5 phút
) -> Dict[str, np.ndarray]:
    """
    Sinh dữ liệu giả cho bài toán giao thông:
    - Đồ thị phẳng (grid 2D) có cộng đồng, luôn liên thông.
    - Mỗi cạnh e có:
        B_e ~ Uniform{bandwidth_low, ..., bandwidth_high}  (nguyên)
        factor_e ~ Uniform[time_factor_low, time_factor_high]
        T_e = dist(u, v) * factor_e
    - Mỗi request có:
        origin, destination, start_time trong [0, time_window_seconds]
    Trả về duy nhất 1 dict.
    """
    rng = np.random.default_rng(seed)

    # =============== 1. Sinh đồ thị phẳng cơ bản ===============
    rows = int(np.floor(np.sqrt(n_nodes)))
    cols = int(np.ceil(n_nodes / rows))
    total_nodes = rows * cols

    G_grid = nx.grid_2d_graph(rows, cols)  # planar

    mapping = {}
    reverse_mapping = {}
    node_id = 0
    for i in range(rows):
        for j in range(cols):
            mapping[(i, j)] = node_id
            reverse_mapping[node_id] = (i, j)
            node_id += 1

    G = nx.Graph()
    for nid in range(min(total_nodes, n_nodes)):
        G.add_node(nid)

    for (u2, v2) in G_grid.edges():
        u = mapping[u2]
        v = mapping[v2]
        if u < n_nodes and v < n_nodes:
            G.add_edge(u, v)

    n_nodes = G.number_of_nodes()

    # =============== 2. Cộng đồng + xoá cạnh ===============
    node_community = np.zeros(n_nodes, dtype=int)
    cols_per_comm = max(1, cols // n_communities)
    for nid in range(n_nodes):
        i, j = reverse_mapping[nid]
        comm = min(j // cols_per_comm, n_communities - 1)
        node_community[nid] = comm

    # Lọc cạnh
    to_remove = []
    for u, v in list(G.edges()):
        cu, cv = node_community[u], node_community[v]
        prob = p_in if cu == cv else p_out
        if rng.random() > prob:
            to_remove.append((u, v))
    G.remove_edges_from(to_remove)

    # =============== 3. Đảm bảo liên thông ===============
    def ensure_connected(G_):
        while not nx.is_connected(G_):
            comps = list(nx.connected_components(G_))
            base = comps[0]
            for u in base:
                i, j = reverse_mapping[u]
                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ii, jj = i + di, j + dj
                    if (ii, jj) not in mapping:
                        continue
                    v = mapping[(ii, jj)]
                    if v < n_nodes and not G_.has_edge(u, v):
                        G_.add_edge(u, v)
                        break
                if nx.is_connected(G_):
                    break

    ensure_connected(G)

    # =============== 4. Gán toạ độ, B_e, T_e ===============
    node_coords = np.zeros((n_nodes, 2))
    for nid in range(n_nodes):
        i, j = reverse_mapping[nid]
        node_coords[nid] = [j, -i]

    edges = list(G.edges())
    m = len(edges)

    edge_u = np.zeros(m, dtype=int)
    edge_v = np.zeros(m, dtype=int)

    # B_e random nguyên, mỗi cạnh một giá trị
    edge_bandwidth = rng.integers(bandwidth_low, bandwidth_high + 1, size=m).astype(float)

    # factor_e random, mỗi cạnh một giá trị
    edge_time_factor = rng.uniform(time_factor_low, time_factor_high, size=m)
    edge_travel_time = np.zeros(m, dtype=float)

    adj_bandwidth = np.zeros((n_nodes, n_nodes), dtype=float)
    adj_travel = np.full((n_nodes, n_nodes), np.inf, dtype=float)

    for k, (u, v) in enumerate(edges):
        edge_u[k], edge_v[k] = u, v

        # dist trên grid
        du = node_coords[u] - node_coords[v]
        dist = float(np.linalg.norm(du))

        # travel time = dist * factor_e
        t = dist * edge_time_factor[k]
        edge_travel_time[k] = t

        B = edge_bandwidth[k]
        adj_bandwidth[u, v] = adj_bandwidth[v, u] = B
        adj_travel[u, v] = adj_travel[v, u] = t

    # =============== 5. Sinh request (5 phút) ===============
    origins = rng.integers(0, n_nodes, size=n_vehicles)
    destinations = rng.integers(0, n_nodes, size=n_vehicles)
    for i in range(n_vehicles):
        if origins[i] == destinations[i]:
            choices = np.setdiff1d(np.arange(n_nodes), [origins[i]])
            destinations[i] = rng.choice(choices)
    start_times = rng.uniform(0, time_window_seconds, size=n_vehicles)

    # =============== 6. Gói toàn bộ dữ liệu vào 1 dict duy nhất ===============
    data = dict(
        graph=G,
        node_coords=node_coords,
        node_community=node_community,
        edge_u=edge_u,
        edge_v=edge_v,
        edge_bandwidth=edge_bandwidth,
        edge_travel_time=edge_travel_time,
        edge_time_factor=edge_time_factor,
        adjacency_bandwidth=adj_bandwidth,
        adjacency_travel_time=adj_travel,
        vehicle_origin=origins,
        vehicle_destination=destinations,
        vehicle_start_time=start_times,
        vehicle_id=np.arange(n_vehicles),
        n_nodes=n_nodes,
        n_edges=m,
        n_vehicles=n_vehicles,
    )

    return data

import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots


def _generate_n_colors(num_colors: int) -> list:
    """
    Sinh num_colors màu khác nhau bằng cách chia đều trên vòng màu HSV.
    Trả về list hex string: ["#rrggbb", ...]
    """
    if num_colors <= 0:
        return []
    colors = []
    hues = np.linspace(0.0, 1.0, num_colors, endpoint=False)
    s = 0.6
    v = 0.9
    for h in hues:
        i = int(h * 6.0)
        f = h * 6.0 - i
        p = v * (1.0 - s)
        q = v * (1.0 - f * s)
        t = v * (1.0 - (1.0 - f) * s)
        i = i % 6
        if i == 0:
            r, g, b = v, t, p
        elif i == 1:
            r, g, b = q, v, p
        elif i == 2:
            r, g, b = p, v, t
        elif i == 3:
            r, g, b = p, q, v
        elif i == 4:
            r, g, b = t, p, v
        else:
            r, g, b = v, p, q
        R = int(r * 255)
        G = int(g * 255)
        B = int(b * 255)
        colors.append(f"#{R:02x}{G:02x}{B:02x}")
    return colors


def visualize_traffic_scenario_plotly_planar(
    data: dict,
    routes: np.ndarray,          # (n_vehicles, n_nodes), padded với -1
    show_vehicle_sample: int | None = None,  # None = vẽ toàn bộ
    node_size: int = 10,
):
    """
    Visualize kịch bản giao thông trên đồ thị phẳng + output routes.

    - Mỗi cạnh hiển thị nhãn: used/B
        + used = số route sử dụng cạnh đó
        + B    = edge_bandwidth

    - Cột trái: graph phẳng
        + Node xám
        + Edge xám, nhãn "used/B"
        + Mỗi request i (trong sample):
            * origin: triangle-up, màu riêng
            * dest  : triangle-down, cùng màu
            * route : polyline nối các node trong routes[i]

    - Cột phải: Gantt chart theo travel time:
        + Y = "req i"
        + X = [start, end], với end = start + tổng travel_time trên route.
    """
    G = data["graph"]
    n_nodes = int(data["n_nodes"])

    node_coords = data["node_coords"]
    edge_u = data["edge_u"]
    edge_v = data["edge_v"]
    edge_bandwidth = data["edge_bandwidth"]
    node_community = data["node_community"]
    origins = data["vehicle_origin"]
    destinations = data["vehicle_destination"]
    start_times = data["vehicle_start_time"]
    vehicle_id = data["vehicle_id"]
    adj_travel = data["adjacency_travel_time"]  # (n_nodes, n_nodes)

    n_vehicles = int(vehicle_id.shape[0])
    req_id = vehicle_id + 1  # đánh số request từ 1

    # safety check cho routes
    assert routes.shape[0] == n_vehicles, "routes.shape[0] phải = n_vehicles"

    # chọn sample request để vẽ trên graph
    if show_vehicle_sample is None or show_vehicle_sample >= n_vehicles:
        sample_idx = np.arange(n_vehicles)
    else:
        sample_idx = np.argsort(start_times)[:show_vehicle_sample]

    # ==========================
    # 0) Bảng màu per-request
    # ==========================
    max_rid = int(req_id.max())
    color_list = _generate_n_colors(max_rid)
    req_colors = {rid: color_list[rid - 1] for rid in range(1, max_rid + 1)}

    # ==========================
    # 0.5) Tính usage cho từng cạnh từ routes
    # ==========================
    from collections import defaultdict
    edge_usage_map = defaultdict(int)  # key = (min(u,v), max(u,v))

    for v in range(n_vehicles):
        seq = routes[v]
        seq = seq[seq >= 0]
        if seq.size < 2:
            continue
        for u_node, w_node in zip(seq[:-1], seq[1:]):
            u = int(u_node)
            w = int(w_node)
            if u == w:
                continue
            key = (u, w) if u < w else (w, u)
            edge_usage_map[key] += 1

    m = edge_u.shape[0]
    edge_usage = np.zeros(m, dtype=int)
    for idx, (u, v) in enumerate(zip(edge_u, edge_v)):
        key = (int(u), int(v)) if u < v else (int(v), int(u))
        edge_usage[idx] = edge_usage_map.get(key, 0)

    # ==========================
    # 1) Graph: nodes + edges
    # ==========================
    x_nodes = node_coords[:, 0]
    y_nodes = node_coords[:, 1]

    node_trace = go.Scatter(
        x=x_nodes,
        y=y_nodes,
        mode="markers",
        marker=dict(
            size=node_size,
            color="lightgray",
            line=dict(width=0.5, color="black"),
        ),
        text=[f"node {i}, comm {c}" for i, c in enumerate(node_community)],
        hoverinfo="text",
        name="nodes",
    )

    # Cạnh: màu xám + nhãn used/B
    edge_x, edge_y = [], []
    mid_x, mid_y, edge_text = [], [], []

    for u, v, B, used in zip(edge_u, edge_v, edge_bandwidth, edge_usage):
        x0, y0 = node_coords[u]
        x1, y1 = node_coords[v]
        edge_x += [x0, x1, None]
        edge_y += [y0, y1, None]

        mid_x.append((x0 + x1) / 2.0)
        mid_y.append((y0 + y1) / 2.0)
        edge_text.append(f"{int(used)}/{int(B)}")

    edge_lines_trace = go.Scatter(
        x=edge_x,
        y=edge_y,
        mode="lines",
        line=dict(width=2, color="lightgray"),
        hoverinfo="none",
        showlegend=False,
    )

    edge_label_trace = go.Scatter(
        x=mid_x,
        y=mid_y,
        mode="text",
        text=edge_text,
        textposition="top center",  # nhãn nằm phía trên cạnh
        textfont=dict(size=10, color="black", family="Arial Black"),
        hoverinfo="text",
        showlegend=False,
        name="usage/capacity",
    )

    # ==========================
    # 2) Request markers + ROUTES trên graph
    # ==========================
    request_graph_traces = []
    for idx in sample_idx:
        rid = int(req_id[idx])
        o = int(origins[idx])
        d = int(destinations[idx])
        color = req_colors[rid]
        group_name = f"req {rid}"

        # Route polyline (nếu có ít nhất 2 node hợp lệ)
        route_nodes = routes[idx]
        route_nodes = route_nodes[route_nodes >= 0]
        if route_nodes.size >= 2:
            x_route = node_coords[route_nodes, 0]
            y_route = node_coords[route_nodes, 1]
            route_trace = go.Scatter(
                x=x_route,
                y=y_route,
                mode="lines",
                line=dict(width=3, color=color),
                name=group_name,
                legendgroup=group_name,
                showlegend=False,
                hoverinfo="text",
                hovertext=[f"{group_name} path node {int(n)}" for n in route_nodes],
            )
            request_graph_traces.append(route_trace)

        # Origin: triangle-up, có legend
        origin_trace = go.Scatter(
            x=[node_coords[o, 0]],
            y=[node_coords[o, 1]],
            mode="markers",
            marker=dict(
                size=node_size * 1.9,
                symbol="triangle-up",
                color=color,
                line=dict(width=2, color="black"),
            ),
            name=group_name,
            legendgroup=group_name,
            showlegend=True,
            hovertext=[f"{group_name} origin: node {o} → dest node {d}"],
            hoverinfo="text",
        )

        # Destination: triangle-down
        dest_trace = go.Scatter(
            x=[node_coords[d, 0]],
            y=[node_coords[d, 1]],
            mode="markers",
            marker=dict(
                size=node_size * 1.9,
                symbol="triangle-down",
                color=color,
                line=dict(width=2, color="black"),
            ),
            name=group_name,
            legendgroup=group_name,
            showlegend=False,
            hovertext=[f"{group_name} dest: node {d} (origin {o})"],
            hoverinfo="text",
        )

        request_graph_traces.append(origin_trace)
        request_graph_traces.append(dest_trace)

    # ==========================
    # 3) Gantt chart theo travel_time
    # ==========================
    timeline_traces = []

    for v_idx, (rid, start) in enumerate(zip(req_id, start_times)):
        rid_int = int(rid)
        color = req_colors[rid_int]
        group_name = f"req {rid_int}"
        y_label = f"req {rid_int}"

        seq = routes[v_idx]
        seq = seq[seq >= 0]
        total_travel = 0.0
        if seq.size >= 2:
            for u_node, w_node in zip(seq[:-1], seq[1:]):
                u = int(u_node)
                w = int(w_node)
                total_travel += float(adj_travel[u, w])

        duration = total_travel
        end_time = start + duration

        # Nếu duration = 0 (không route / route rỗng), vẫn vẽ milestone mỏng
        if duration <= 0:
            duration = 1e-6  # thanh rất mỏng, coi như mốc

        bar = go.Bar(
            x=[duration],
            y=[y_label],
            base=[start],
            orientation="h",
            marker=dict(color=color),
            name=group_name,
            legendgroup=group_name,
            showlegend=False,  # legend ở graph
            hovertemplate=(
                "req %{y}<br>"
                "start=%{base:.1f}s<br>"
                "duration=%{x:.1f}s<br>"
                f"end={end_time:.1f}s"
                "<extra></extra>"
            ),
        )

        timeline_traces.append(bar)

    # ==========================
    # 4) Subplots & layout
    # ==========================
    fig = make_subplots(
        rows=1, cols=2,
        column_widths=[0.6, 0.4],
        subplot_titles=("Planar traffic graph", "Request Gantt chart (travel time)"),
    )

    # cột 1: graph phẳng
    fig.add_trace(edge_lines_trace, row=1, col=1)
    fig.add_trace(edge_label_trace, row=1, col=1)
    fig.add_trace(node_trace, row=1, col=1)
    for tr in request_graph_traces:
        fig.add_trace(tr, row=1, col=1)

    fig.update_xaxes(visible=False, row=1, col=1)
    fig.update_yaxes(visible=False, row=1, col=1)
    fig.update_yaxes(scaleanchor="x", scaleratio=1, row=1, col=1)

    # cột 2: Gantt chart
    for tr in timeline_traces:
        fig.add_trace(tr, row=1, col=2)

    fig.update_xaxes(title_text="time (s)", row=1, col=2)
    fig.update_yaxes(title_text="request", row=1, col=2, autorange="reversed")

    fig.update_layout(
        title="Planar traffic scenario – per-edge usage/capacity and per-request travel-time Gantt chart",
        barmode="stack",  # mỗi req một thanh riêng, không chồng nhau theo y
        legend=dict(
            orientation="v",
            yanchor="top",
            y=0.98,
            xanchor="left",
            x=1.02,
        ),
        height=650,
    )

    fig.show()

data = generate_planar_traffic_data(
    n_nodes=90,
    n_vehicles=30,
    n_communities=3,
    bandwidth_low = 5,
    bandwidth_high = 8,
    p_in=0.7,
    p_out=0.5,
    seed=42,
)

# fake routes: mỗi xe đi từ origin → dest bằng path ngắn nhất
G = data["graph"]
n_vehicles = data["n_vehicles"]
n_nodes = data["n_nodes"]
routes = -np.ones((n_vehicles, n_nodes), dtype=int)

for v in range(n_vehicles):
    s = int(data["vehicle_origin"][v])
    t = int(data["vehicle_destination"][v])
    path = nx.shortest_path(G, s, t)
    routes[v, :len(path)] = path

visualize_traffic_scenario_plotly_planar(
    data,
    routes,
    node_size=12,
)

import numpy as np
from numba import njit


# ============================================================
# 1) Dijkstra O(n^2) trên ma trận kề
# ============================================================


def dijkstra_shortest_path(adjacency_travel_time: np.ndarray,
                           source: int,
                           target: int) -> tuple:
    """
    Dijkstra đơn giản O(n^2) trên ma trận kề:
    - adjacency_travel_time[u, v] = time (float) hoặc np.inf nếu không có cạnh.
    Trả về:
    - total_cost: float
    - path: np.ndarray shape (n_nodes,), là chuỗi node từ source → target, padding -1.
    """
    n_nodes = adjacency_travel_time.shape[0]
    dist = np.full(n_nodes, np.inf)
    prev = np.full(n_nodes, -1, dtype=np.int64)
    visited = np.zeros(n_nodes, dtype=np.bool_)

    dist[source] = 0.0

    for _ in range(n_nodes):
        # Chọn node chưa visit có dist nhỏ nhất
        u = -1
        min_val = np.inf
        for i in range(n_nodes):
            if (not visited[i]) and (dist[i] < min_val):
                min_val = dist[i]
                u = i

        if u == -1:
            # Không còn node reachable
            break
        if u == target:
            # Đã tới target
            break

        visited[u] = True

        # Relax các neighbor
        row = adjacency_travel_time[u]
        for v in range(n_nodes):
            w = row[v]
            if w == np.inf:
                continue
            alt = dist[u] + w
            if alt < dist[v]:
                dist[v] = alt
                prev[v] = u

    # reconstruct path
    path = np.full(n_nodes, -1, dtype=np.int64)
    if dist[target] == np.inf:
        # không tìm được đường
        return dist[target], path

    tmp = np.full(n_nodes, -1, dtype=np.int64)
    idx = 0
    cur = target
    while cur != -1 and idx < n_nodes:
        tmp[idx] = cur
        cur = prev[cur]
        idx += 1

    # đảo lại tmp[0:idx] để thành path đúng thứ tự
    for i in range(idx):
        path[i] = tmp[idx - 1 - i]

    return dist[target], path


# ============================================================
# 2) Helper: tính cost travel time của 1 path trên ma trận kề
# ============================================================


def _compute_path_travel_cost(path: np.ndarray,
                              adjacency_travel_time: np.ndarray) -> float:
    """
    Tính tổng travel time của path trên adjacency_travel_time.
    path: (n_nodes,), padding -1.
    """
    n_nodes = path.shape[0]
    total = 0.0
    for i in range(n_nodes - 1):
        u = path[i]
        v = path[i + 1]
        if v < 0:
            break
        w = adjacency_travel_time[u, v]
        if w == np.inf:
            return np.inf
        total += w
    return total


# ============================================================
# 3) Yen's algorithm: K-shortest simple paths giữa (s, t)
#    Dùng mảng cố định, không dùng list/heap
# ============================================================


def yen_k_shortest_paths(
    adjacency_travel_time: np.ndarray,
    source: int,
    target: int,
    k_paths: int,
) -> tuple:
    """
    Yen's algorithm (dạng array, Numba-friendly) để sinh tối đa K đường đi đơn giản
    ngắn nhất (theo travel time) giữa (source, target).

    Giả định:
    - adjacency_travel_time: (n_nodes, n_nodes), np.inf nếu không cạnh.
    - Đồ thị vô hướng hoặc có hướng đều được, miễn ma trận kề đúng.

    Trả về:
    - costs: shape (k_paths,), cost[i] = travel time của đường thứ i (có thể là np.inf nếu thiếu).
    - paths: shape (k_paths, n_nodes), mỗi hàng là path, padding -1.
    """
    n_nodes = adjacency_travel_time.shape[0]

    # ==== Kết quả ====
    paths = np.full((k_paths, n_nodes), -1, dtype=np.int64)
    costs = np.full(k_paths, np.inf)

    # ==== Candidate set (B) ====
    # Upper bound số candidate: k_paths * n_nodes là đủ rộng cho K nhỏ.
    max_candidates = k_paths * n_nodes
    cand_paths = np.full((max_candidates, n_nodes), -1, dtype=np.int64)
    cand_costs = np.full(max_candidates, np.inf)
    cand_used = np.zeros(max_candidates, dtype=np.bool_)  # True = slot đang dùng (valid candidate)

    # ---- Bước 1: đường đi ngắn nhất đầu tiên ----
    base_cost, base_path = dijkstra_shortest_path(adjacency_travel_time, source, target)
    if base_cost == np.inf:
        # Không có path nào
        return costs, paths

    for j in range(n_nodes):
        paths[0, j] = base_path[j]
    costs[0] = base_cost

    num_found = 1  # số path đã chấp nhận (A)

    # ---- Hàm phụ: so sánh 2 path có bằng nhau không ----

    def _is_same_path(path1: np.ndarray, path2: np.ndarray) -> bool:
        for idx in range(n_nodes):
            a = path1[idx]
            b = path2[idx]
            if a == -1 and b == -1:
                # Kết thúc đồng thời
                return True
            if a != b:
                return False
        return True

    # ---- Hàm phụ: thêm candidate (nếu không trùng) ----

    def _add_candidate(new_path: np.ndarray,
                       new_cost: float,
                       paths_A: np.ndarray,
                       num_A: int,
                       cand_paths_local: np.ndarray,
                       cand_costs_local: np.ndarray,
                       cand_used_local: np.ndarray) -> None:
        # bỏ qua nếu cost inf
        if new_cost == np.inf:
            return

        # kiểm tra trùng với A
        for ii in range(num_A):
            if _is_same_path(new_path, paths_A[ii]):
                return

        # kiểm tra trùng với candidate đã có
        max_c = cand_paths_local.shape[0]
        for c in range(max_c):
            if cand_used_local[c]:
                if _is_same_path(new_path, cand_paths_local[c]):
                    return

        # tìm slot trống để ghi candidate
        free_idx = -1
        for c in range(max_c):
            if not cand_used_local[c]:
                free_idx = c
                break
        if free_idx == -1:
            # Hết slot candidate (trường hợp này hiếm, nhưng ta bỏ qua)
            return

        for j in range(n_nodes):
            cand_paths_local[free_idx, j] = new_path[j]
        cand_costs_local[free_idx] = new_cost
        cand_used_local[free_idx] = True

    # ---- Hàm phụ: chọn candidate tốt nhất ----

    def _pop_best_candidate(cand_paths_local: np.ndarray,
                            cand_costs_local: np.ndarray,
                            cand_used_local: np.ndarray) -> tuple:
        best_idx = -1
        best_cost = np.inf
        max_c = cand_paths_local.shape[0]
        for c in range(max_c):
            if cand_used_local[c]:
                cost_c = cand_costs_local[c]
                if cost_c < best_cost:
                    best_cost = cost_c
                    best_idx = c

        return best_idx, best_cost

    # ---- Vòng lặp Yen cho k = 2..K ----
    for k in range(1, k_paths):
        # Nếu path trước đó là inf, nghĩa là không còn path → break
        if costs[k - 1] == np.inf:
            break

        prev_path = paths[k - 1]

        # Spur từ từng nút trong prev_path
        # Tìm độ dài thực của prev_path
        path_len = 0
        for i in range(n_nodes):
            if prev_path[i] == -1:
                break
            path_len += 1

        # Đặt spur node từ 0 đến path_len-2 (node cuối không thể spur)
        for i in range(path_len - 1):
            spur_node = prev_path[i]

            # Tạo bản copy adjacency để xoá cạnh/nút
            adj_tmp = adjacency_travel_time.copy()

            # 1) Xoá các cạnh (v_i, next) của những path trong A có cùng prefix
            for a_idx in range(num_found):
                pathA = paths[a_idx]

                # Kiểm tra prefix pathA[0..i] == prev_path[0..i]
                same_prefix = True
                for idx_p in range(i + 1):
                    if pathA[idx_p] != prev_path[idx_p]:
                        same_prefix = False
                        break

                if same_prefix:
                    next_node = pathA[i + 1]
                    if next_node != -1:
                        # Xoá cạnh (spur_node, next_node)
                        adj_tmp[spur_node, next_node] = np.inf
                        adj_tmp[next_node, spur_node] = np.inf

            # 2) Xoá các nút thuộc prefix trước spur node (v_0..v_{i-1})
            for j in range(i):
                ban_node = prev_path[j]
                if ban_node == -1:
                    break
                # Xoá mọi cạnh nối tới ban_node
                for v in range(n_nodes):
                    adj_tmp[ban_node, v] = np.inf
                    adj_tmp[v, ban_node] = np.inf

            # 3) Chạy Dijkstra từ spur_node đến target trên adj_tmp
            spur_cost, spur_path = dijkstra_shortest_path(adj_tmp, spur_node, target)
            if spur_cost == np.inf:
                # không có spur path
                continue

            # 4) Ghép root prefix + spur path (bỏ spur_node trùng)
            new_path = np.full(n_nodes, -1, dtype=np.int64)
            pos = 0

            # copy root prefix (v_0..v_i)
            for idx_p in range(i + 1):
                new_path[pos] = prev_path[idx_p]
                pos += 1

            # copy spur_path[1..] (bỏ spur_node)
            for idx_spur in range(1, n_nodes):
                node_sp = spur_path[idx_spur]
                if node_sp == -1:
                    break
                if pos >= n_nodes:
                    break
                new_path[pos] = node_sp
                pos += 1

            # 5) Tính travel cost thực trên adjacency_travel_time gốc
            new_cost = _compute_path_travel_cost(new_path, adjacency_travel_time)
            if new_cost == np.inf:
                continue

            # 6) Thêm vào candidate set nếu không trùng
            _add_candidate(new_path, new_cost,
                           paths, num_found,
                           cand_paths, cand_costs, cand_used)

        # Sau khi xử lý tất cả spur của P_{k-1}, lấy candidate tốt nhất
        best_idx, best_cost = _pop_best_candidate(cand_paths, cand_costs, cand_used)
        if best_idx == -1 or best_cost == np.inf:
            # Không còn candidate
            break

        # Chấp nhận candidate thành P_k
        for j in range(n_nodes):
            paths[num_found, j] = cand_paths[best_idx, j]
        costs[num_found] = best_cost
        num_found += 1

        # Đánh dấu candidate này không dùng nữa
        cand_used[best_idx] = False
        cand_costs[best_idx] = np.inf

        if num_found >= k_paths:
            break

    # Nếu num_found < k_paths, các phần còn lại đã là np.inf / -1 sẵn
    return costs, paths


# ============================================================
# 4) Tính K shortest paths cho toàn bộ vehicle bằng Yen
# ============================================================


def compute_all_k_shortest_paths(
    adjacency_travel_time: np.ndarray,
    vehicle_origin: np.ndarray,
    vehicle_destination: np.ndarray,
    k_paths: int,
) -> tuple:
    """
    Tính K-shortest simple paths (Yen) cho toàn bộ chuyến.
    Trả về:
    - base_costs: (n_vehicles, k_paths)
    - all_paths:  (n_vehicles, k_paths, n_nodes)
    """
    n_vehicles = vehicle_origin.shape[0]
    n_nodes = adjacency_travel_time.shape[0]

    base_costs = np.full((n_vehicles, k_paths), np.inf)
    all_paths = np.full((n_vehicles, k_paths, n_nodes), -1, dtype=np.int64)

    for v in range(n_vehicles):
        s = int(vehicle_origin[v])
        t = int(vehicle_destination[v])
        costs_v, paths_v = yen_k_shortest_paths(
            adjacency_travel_time, s, t, k_paths
        )
        for kk in range(k_paths):
            base_costs[v, kk] = costs_v[kk]
            for j in range(n_nodes):
                all_paths[v, kk, j] = paths_v[kk, j]

    return base_costs, all_paths


# ============================================================
# 5) Build edge list & index từ adjacency_bandwidth
# ============================================================


def build_edge_list_and_index(adjacency_bandwidth: np.ndarray) -> tuple:
    """
    Từ adjacency_bandwidth (n_nodes, n_nodes) sinh:
    - edge_u[m], edge_v[m], edge_bandwidth[m]
    - edge_index_matrix[n_nodes, n_nodes]: index cạnh hoặc -1.
    Giả định đồ thị vô hướng, chỉ lấy nửa trên (u < v).
    """
    n_nodes = adjacency_bandwidth.shape[0]

    # Đếm số cạnh
    m = 0
    for u in range(n_nodes):
        for v in range(u + 1, n_nodes):
            if adjacency_bandwidth[u, v] > 0.0:
                m += 1

    edge_u = np.full(m, 0, dtype=np.int64)
    edge_v = np.full(m, 0, dtype=np.int64)
    edge_bandwidth = np.zeros(m, dtype=np.float64)
    edge_index_matrix = np.full((n_nodes, n_nodes), -1, dtype=np.int64)

    idx = 0
    for u in range(n_nodes):
        for v in range(u + 1, n_nodes):
            if adjacency_bandwidth[u, v] > 0.0:
                edge_u[idx] = u
                edge_v[idx] = v
                edge_bandwidth[idx] = adjacency_bandwidth[u, v]
                edge_index_matrix[u, v] = idx
                edge_index_matrix[v, u] = idx
                idx += 1

    return edge_u, edge_v, edge_bandwidth, edge_index_matrix


# ============================================================
# 6) Tính incremental cost (travel + congestion penalty) cho 1 path
# ============================================================


def _compute_incremental_cost_for_path(path: np.ndarray,
                                       base_cost: float,
                                       edge_index_matrix: np.ndarray,
                                       edge_bandwidth: np.ndarray,
                                       edge_loads: np.ndarray,
                                       beta_penalty: float) -> float:
    """
    Tính cost (travel + penalty) nếu GÁN THÊM 1 xe vào path này.
    - base_cost: travel time thuần (sum c_e).
    - penalty_e = exp(beta * overflow_ratio_e),
      overflow_ratio_e = (load_e + 1)/B_e - 1 nếu > 0, ngược lại không phạt.
    """
    if base_cost == np.inf:
        return np.inf

    n_nodes = path.shape[0]
    total_penalty = 0.0

    for i in range(n_nodes - 1):
        u = path[i]
        w = path[i + 1]
        if w < 0:
            break

        e_idx = edge_index_matrix[u, w]
        if e_idx < 0:
            continue

        B_e = edge_bandwidth[e_idx]
        new_load = float(edge_loads[e_idx]) + 1.0
        overflow_ratio = new_load / B_e - 1.0

        if overflow_ratio > 0.0:
            total_penalty += np.exp(beta_penalty * overflow_ratio)

    return base_cost + total_penalty


# ============================================================
# 7) Greedy + regret assignment trên K-path đã sinh bởi Yen
# ============================================================

def solve_routing_with_penalty_greedy_regret(
    adjacency_travel_time: np.ndarray,
    adjacency_bandwidth: np.ndarray,
    vehicle_origin: np.ndarray,
    vehicle_destination: np.ndarray,
    k_paths: int = 3,
    beta_penalty: float = 1.0,
    debug: bool = False,
) -> tuple:
    """
    Giải bài toán điều phối xe tự hành trên mạng giao thông với băng thông, bằng:
    - Bước 1: Sinh K-shortest simple paths (Yen) cho mỗi OD-pair.
    - Bước 2: Gán xe theo greedy + regret với cost:
        cost(v,k) = travel_time(P_{v,k})
                    + sum_{e in P_{v,k}} exp(beta * overflow_ratio_e),
        overflow_ratio_e = (load_e + 1)/B_e - 1, chỉ phạt nếu > 0.

    Chính sách regret:
        - Nếu xe v có ≥ 2 path khả thi:  regret(v) = T2(v) - T1(v).
        - Nếu xe v chỉ có 1 path khả thi: regret(v) = BIG_REGRET (ưu tiên rất cao).

    Input:
    - adjacency_travel_time: (n_nodes, n_nodes), np.inf nếu không có cạnh.
    - adjacency_bandwidth:   (n_nodes, n_nodes), 0 nếu không có cạnh, B_e nếu có.
    - vehicle_origin:        (n_vehicles,)
    - vehicle_destination:   (n_vehicles,)
    - k_paths:               số đường đi mỗi chuyến (K).
    - beta_penalty:          β trong exp(β * overflow_ratio).
    - debug:                 nếu True thì in log chi tiết T1, T2, regret, best_v.

    Output:
    - routes_final: (n_vehicles, n_nodes), mỗi hàng là path được chọn, padding -1.
    - edge_loads:   (n_edges,), số xe đi qua mỗi cạnh trong nghiệm cuối cùng.
    - base_costs:   (n_vehicles, k_paths), travel time thuần của các path.
    """
    n_nodes = adjacency_travel_time.shape[0]
    n_vehicles = vehicle_origin.shape[0]

    # 1) Tính K-shortest paths (Yen) cho mỗi xe
    base_costs, all_paths = compute_all_k_shortest_paths(
        adjacency_travel_time,
        vehicle_origin,
        vehicle_destination,
        k_paths,
    )

    # 2) Sinh danh sách cạnh + index matrix từ băng thông
    edge_u, edge_v, edge_bandwidth, edge_index_matrix = build_edge_list_and_index(
        adjacency_bandwidth
    )
    n_edges = edge_u.shape[0]

    # 3) Trạng thái toàn cục
    edge_loads = np.zeros(n_edges, dtype=np.int64)
    routes_final = np.full((n_vehicles, n_nodes), -1, dtype=np.int64)
    assigned = np.zeros(n_vehicles, dtype=np.bool_)
    remaining = n_vehicles

    # 4) Mảng tạm cho mỗi vòng lặp
    T1 = np.zeros(n_vehicles, dtype=np.float64)
    T2 = np.zeros(n_vehicles, dtype=np.float64)
    regret = np.zeros(n_vehicles, dtype=np.float64)
    best_k_for_v = np.zeros(n_vehicles, dtype=np.int64)

    BIG_REGRET = 1e12  # "vô cùng" cho xe chỉ có 1 path khả thi
    iter_no = 0

    while remaining > 0:
        # 4.1) Reset T1, T2, regret, best_k_for_v
        for v in range(n_vehicles):
            T1[v] = np.inf
            T2[v] = np.inf
            regret[v] = -1.0
            best_k_for_v[v] = -1

        # 4.2) Tính T1, T2, regret cho từng xe chưa gán
        for v in range(n_vehicles):
            if assigned[v]:
                continue

            for kk in range(k_paths):
                base_cost = base_costs[v, kk]
                if base_cost == np.inf:
                    continue

                path = all_paths[v, kk]
                total_cost = _compute_incremental_cost_for_path(
                    path,
                    base_cost,
                    edge_index_matrix,
                    edge_bandwidth,
                    edge_loads,
                    beta_penalty,
                )

                if total_cost < T1[v]:
                    T2[v] = T1[v]
                    T1[v] = total_cost
                    best_k_for_v[v] = kk
                elif total_cost < T2[v]:
                    T2[v] = total_cost

            # tính regret cho xe v
            if T1[v] < np.inf:
                if T2[v] < np.inf:
                    regret[v] = T2[v] - T1[v]
                else:
                    regret[v] = BIG_REGRET  # chỉ có 1 path khả thi

        if debug:
            print(f"\n===== ITERATION {iter_no} =====")
            print("v | assigned | best_k |     T1     |     T2     |      regret")
            for v in range(n_vehicles):
                if assigned[v]:
                    continue
                if best_k_for_v[v] == -1:
                    print(f"{v:2d} |    1?    |   -1   |       inf |       inf |         -  ")
                else:
                    t1 = T1[v]
                    t2 = T2[v]
                    r  = regret[v]
                    print(f"{v:2d} |    0     | {best_k_for_v[v]:5d} | {t1:9.2f} | {t2:9.2f} | {r:11.2f}")

        # 4.3) Chọn xe có regret lớn nhất, tie-break theo T1 nhỏ nhất
        best_v = -1
        best_regret = -1.0
        best_T1 = np.inf

        for v in range(n_vehicles):
            if assigned[v]:
                continue
            if best_k_for_v[v] == -1:
                continue  # không có path khả thi

            r = regret[v]
            t1 = T1[v]
            if r > best_regret:
                best_regret = r
                best_T1 = t1
                best_v = v
            elif r == best_regret and t1 < best_T1:
                best_T1 = t1
                best_v = v

        if best_v == -1:
            if debug:
                print("Không còn xe nào có path khả thi, dừng.")
            break

        # 4.4) Gán path tốt nhất cho best_v
        k_star = best_k_for_v[best_v]
        chosen_path = all_paths[best_v, k_star]

        if debug:
            t1 = T1[best_v]
            t2 = T2[best_v]
            r  = regret[best_v]
            print(
                f"\n>>> Chọn xe v = {best_v}, path k* = {k_star}, "
                f"T1 = {t1:.2f}, T2 = {t2:.2f}, regret = {r:.2f}"
            )

        for i in range(n_nodes):
            routes_final[best_v, i] = chosen_path[i]

        # Cập nhật edge_loads
        for i in range(n_nodes - 1):
            u = chosen_path[i]
            w = chosen_path[i + 1]
            if w < 0:
                break
            e_idx = edge_index_matrix[u, w]
            if e_idx >= 0:
                edge_loads[e_idx] += 1

        assigned[best_v] = True
        remaining -= 1
        iter_no += 1

    return routes_final, edge_loads, base_costs

import numpy as np
from numba import njit


# @njit
def solve_routing_without_penalty(
    adjacency_travel_time: np.ndarray,
    vehicle_origin: np.ndarray,
    vehicle_destination: np.ndarray,
) -> tuple:
    """
    Baseline: Mỗi xe đi theo đường đi NGẮN NHẤT,
    KHÔNG xét băng thông, KHÔNG penalty, KHÔNG tương tác giữa các xe.

    - adjacency_travel_time: (n_nodes, n_nodes), np.inf nếu không có cạnh.
    - vehicle_origin:        (n_vehicles,), node xuất phát mỗi xe.
    - vehicle_destination:   (n_vehicles,), node đích mỗi xe.

    Output:
    - routes:      (n_vehicles, n_nodes), mỗi hàng là path đã chọn, padding -1.
    - route_costs: (n_vehicles,), tổng travel time trên path đó (np.inf nếu không tới được).
    """
    n_nodes = adjacency_travel_time.shape[0]
    n_vehicles = vehicle_origin.shape[0]

    routes = np.full((n_vehicles, n_nodes), -1, dtype=np.int64)
    route_costs = np.full(n_vehicles, np.inf)

    for v in range(n_vehicles):
        s = int(vehicle_origin[v])
        t = int(vehicle_destination[v])

        cost, path = dijkstra_shortest_path(adjacency_travel_time, s, t)
        route_costs[v] = cost

        for i in range(n_nodes):
            routes[v, i] = path[i]

    return routes, route_costs

def main():
    # 1. Sinh dữ liệu giả lập
    data = generate_planar_traffic_data(
        n_nodes=90,
        n_vehicles=90,
        n_communities=3,
        p_in=0.7,
        p_out=0.5,
        bandwidth_low=5,
        bandwidth_high=6,
        seed=42,
    )

    # === 1) BASELINE: chỉ đường đi ngắn nhất, không penalty ===
    print("=== Running Baseline: No Penalty ===")
    routes_no_penalty, costs_no_penalty = solve_routing_without_penalty(
        adjacency_travel_time=data["adjacency_travel_time"],
        vehicle_origin=data["vehicle_origin"],
        vehicle_destination=data["vehicle_destination"],
    )

    # === 2) THUẬT TOÁN CHÍNH: có penalty + regret + Yen ===
    print("=== Running Greedy + Regret (Yen K=3) ===")
    routes_regret, edge_loads_regret, base_costs_regret = solve_routing_with_penalty_greedy_regret(
        adjacency_travel_time=data["adjacency_travel_time"],
        adjacency_bandwidth=data["adjacency_bandwidth"],
        vehicle_origin=data["vehicle_origin"],
        vehicle_destination=data["vehicle_destination"],
        k_paths=10,
        beta_penalty=1.0,
    )

    # 2. Tính cost tổng thể để so sánh công bằng
    total_cost_no_penalty = np.nansum(costs_no_penalty)
    mean_cost_no_penalty = np.nanmean(costs_no_penalty)

    # cost của thuật toán regret = tổng base_costs (đã chọn path tốt nhất)
    chosen_costs = np.zeros(base_costs_regret.shape[0])
    for v in range(base_costs_regret.shape[0]):
        # chọn k tốt nhất cho mỗi vehicle (đã lưu trong routes_regret)
        # path đầu tiên của mỗi xe trong routes_regret khớp với k tốt nhất
        # nên lấy base_cost nhỏ nhất tương ứng
        chosen_costs[v] = np.min(base_costs_regret[v])

    total_cost_regret = np.nansum(chosen_costs)
    mean_cost_regret = np.nanmean(chosen_costs)

    # 3. In thống kê tóm tắt
    print("\n=== Summary (Unified Cost Comparison) ===")
    print(f"Baseline (No Penalty): total = {total_cost_no_penalty:.2f}, mean = {mean_cost_no_penalty:.2f}")
    print(f"Greedy + Regret (Yen): total = {total_cost_regret:.2f}, mean = {mean_cost_regret:.2f}")

    # 4. Vẽ để so sánh
    print("\n=== Visualizing ===")
    print("1) Baseline (No Penalty)")
    visualize_traffic_scenario_plotly_planar(data, routes_no_penalty, node_size=12)

    print("2) Greedy + Regret (Yen)")
    visualize_traffic_scenario_plotly_planar(data, routes_regret, node_size=12)


if __name__ == "__main__":
    main()